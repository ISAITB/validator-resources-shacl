# baseURI: http://www.w3.org/ns/shacl-shacl#

# A SHACL shapes graph to validate SHACL shapes graphs  (Extended)
# Draft last edited 2020-03-13

@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh:   <http://www.w3.org/ns/shacl#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

@prefix shsh: <http://www.w3.org/ns/shacl-shacl#> .

shsh:
	rdfs:label "SHACL for SHACL"@en ;
	rdfs:comment "This shapes graph can be used to validate SHACL shapes graphs against a subset of the syntax rules."@en ;
	sh:declare [
		sh:prefix "shsh" ;
		sh:namespace "http://www.w3.org/ns/shacl-shacl#" ;
	] .

shsh:SparqlShapeShape
	a sh:NodeShape ;
	sh:targetObjectsOf sh:sparql ;    	# sparql-nodeKind
	sh:message "Shapes may have values for the property sh:sparql, and these values are either IRIs or blank nodes.";
	sh:or ( [ sh:nodeKind sh:BlankNode ] [ sh:nodeKind sh:IRI ] ) ;
	
	sh:property [
		sh:path sh:select ;				
		sh:message "SPARQL-based constraints have exactly one value for the property sh:select.";
		sh:maxCount 1 ;					# SPARQLConstraint-select-count
		sh:minCount 1 ;					# SPARQLConstraint-select-count
	] ;
	
	sh:property [
		sh:path sh:select ;	
		sh:message "The value of sh:select is a literal of datatype xsd:string.";
		sh:nodeKind sh:Literal ;		# SPARQLConstraint-select-datatype
	] ;
	
	sh:property [
		sh:path sh:select ;	
		sh:message "Using the prefix handling rules, the value of sh:select is not a valid SPARQL 1.1 SELECT query.";
		sh:pattern "SELECT.*WHERE(\\s*)\\{.*\\}" ;		# select-query-valid
		sh:flags "si" ;
	] ;
	
	sh:property [
		sh:path sh:select ;	
		sh:message "The SPARQL query derived from the value of sh:select projects the variable this in the SELECT clause.";
		sh:pattern "SELECT.*\\$this.*WHERE.*" ;		# select-query-this
		sh:flags "si" ;
	] ;
	
	# sh:property [
		# sh:path sh:select ;	
		# sh:message "The only legal use of the variable PATH in the SPARQL queries of SPARQL-based constraints and SELECT-based validators is in the predicate position of a triple # pattern.";
		# sh:pattern "((\\$|\\?|[A-Z]*:)[A-Z]*(\\s*)(\\$PATH)(\\s*)(\\$|\\?|[A-Z]*:)[A-Z]*(\\s*).)+" ;		# PATH-position
		# sh:pattern "((\\$|\\?)[A-Z]*(\\s*)\\$PATH(\\s*)(\\$|\\?)[A-Z]*(\\s*).)+" ;		# PATH-position
		# sh:flags "si" ;
	# ] ;
	
	sh:property [
		sh:path sh:message ;
		sh:message "SPARQL-based constraints may have values for the property sh:message and these are either xsd:string literals or literals with a language tag.";
		sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ; 		# SPARQLConstraint-message-datatype
	] ;
	
	sh:property [
		sh:path sh:deactivated ;
		sh:message "SPARQL-based constraints may have at most one value for the property sh:deactivated.";
		sh:maxCount 1 ;					# SPARQLConstraint-deactivated-maxCount
	] ;
	
	sh:property [
		sh:path sh:prefixes ;
		sh:message "The values of sh:prefixes are either IRIs or blank nodes.";
		sh:or ( [ sh:nodeKind sh:BlankNode ] [ sh:nodeKind sh:IRI ] ) ;				# prefixes-nodeKind
	] . 

shsh:DeclareShapeShape
	a sh:NodeShape ;
	sh:targetObjectsOf sh:declare ;    	# declare-nodeKind
	sh:message "The values of the property sh:declare are IRIs or blank nodes.";
	sh:or ( [ sh:nodeKind sh:BlankNode ] [ sh:nodeKind sh:IRI ] ) ;
	
	sh:property [
		sh:path sh:prefix ;				
		sh:message "Prefix declarations have exactly one value for the property sh:prefix.";
		sh:maxCount 1 ;					# prefix-count
		sh:minCount 1 ;					# prefix-count
	] ;
	
	sh:property [
		sh:path sh:prefix ;
		sh:message "The values of sh:prefix are literals of datatype xsd:string.";
		sh:datatype xsd:string ; 		# prefix-datatype
	] ;
	
	sh:property [
		sh:path sh:namespace ;				
		sh:message "Prefix declarations have exactly one value for the property sh:namespace.";
		sh:maxCount 1 ;					# namespace-count
		sh:minCount 1 ;					# namespace-count
	] ;
	
	sh:property [
		sh:path sh:namespace ;
		sh:message "The values of sh:namespace are literals of datatype xsd:anyURI.";
		sh:datatype xsd:anyURI ; 		# namespace-datatype
	] .

shsh:ContstraintComponentShape
	a sh:NodeShape ;			
	sh:targetClass sh:ConstraintComponent ;		# ConstraintComponent
	
	sh:property [
		sh:path (sh:parameter sh:optional) ;
		sh:message "The values of sh:optional must be literals with datatype xsd:boolean.";
		sh:datatype xsd:boolean ;		# optional-datatype
	] ;
	
	sh:property [
		sh:path (sh:parameter sh:optional) ;
		sh:message "A parameter declaration can have at most one value for the property sh:optional.";
		sh:maxCount 1 ;	 				# optional-maxCount
	] ;
	
	sh:property [
		sh:path sh:labelTemplate ;
		sh:message "The values of sh:labelTemplate are strings (possibly with language tag).";
		sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ; 				# labelTemplate-datatype
	] .
	
	
	#sh:targetObjectsOf sh:parameter ;  
	#sh:message "A SPARQL-based constraint component is an IRI that has SHACL type sh:ConstraintComponent in the shapes graph.";
	#sh:nodeKind sh:IRI .
	
	#sh:property [
	#	sh:path sh:path ;
	#	sh:message "Parameter names must not be one of the following: this, shapesGraph, currentShape, path, PATH, value.";
	#	sh:pattern "((?!this).)*" ;		# parameter-name-not-in
	#	sh:flags "s" ;
	#] .

shsh:SELECTBasedShapes
	a sh:NodeShape ;	
	sh:targetSubjectsOf sh:nodeValidator, sh:propertyValidator ;
	
	sh:property [
		sh:path sh:nodeValidator ;
		sh:message "The values of sh:nodeValidator must be SELECT-based validators.";
		sh:class sh:SPARQLSelectValidator ;				# nodeValidator-class
	] ;
		
	sh:property [
		sh:path sh:propertyValidator ;
		sh:message "The values of sh:propertyValidator must be SELECT-based validators.";
		sh:class sh:SPARQLSelectValidator ;				# propertyValidator-class
	] .
	
shsh:SELECTBasedShapesClass
	a sh:NodeShape ;			
	sh:targetClass sh:SPARQLSelectValidator ;	
	
	sh:property [
		sh:path sh:select ;
		sh:message "SELECT-based validators have exactly one value for the property sh:select.";
		sh:maxCount 1 ;	 				# SPARQLSelectValidator-select-count
		sh:minCount 1 ;	 				# SPARQLSelectValidator-select-count
	] .

shsh:ASKBasedShapes
	a sh:NodeShape ;
	sh:targetSubjectsOf sh:validator ;
	
	sh:property [
		sh:path sh:validator ;
		sh:message "The values of sh:validator must be ASK-based validators.";
		sh:class sh:SPARQLAskValidator ;				# validator-class
	] .
	
shsh:ASKBasedShapesClass
	a sh:NodeShape ;			
	sh:targetClass sh:SPARQLAskValidator ;	
	
	sh:property [
		sh:path sh:ask ;
		sh:message "ASK-based validators have exactly one value for the property sh:ask.";
		sh:maxCount 1 ;	 				# ask-count
		sh:minCount 1 ;	 				# ask-count
	] ;
	
	sh:property [
		sh:path sh:ask ;
		sh:message "The value of sh:ask must be a literal with datatype xsd:string.";
		sh:datatype xsd:string ;	 				# ask-datatype
	] ;
	
	sh:property [
		sh:path sh:ask ;	
		sh:message "The value of sh:ask must be a valid SPARQL ASK query using the aforementioned prefix handling rules.";
		sh:pattern "ASK(.*FROM.*>)*.*WHERE(\\s*)\\{.*\\}" ;		# ask-sparql
		sh:flags "si" ;
	] .
	
	